#include "dns_util.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <time.h>
#include <errno.h>

using namespace boost;

void test_offline() {
	
	printf("Test offline ...\n");
	// Full content captured by wireshark
        /*
	unsigned char DNS_req_packet[79] = {
	0x00, 0x0c, 0x29, 0x6e, 0x5d, 0x15, 0x00, 0x1e, 0x4c, 0x8c, 0xe5, 0xdb, 0x08, 0x00, 0x45, 0x00,
	0x00, 0x39, 0x17, 0xd1, 0x00, 0x00, 0x40, 0x11, 0x15, 0x19, 0xc0, 0xa8, 0xe6, 0x53, 0xc0, 0xa8,
	0xe6, 0x25, 0xa6, 0x3f, 0x00, 0x35, 0x00, 0x25, 0xe9, 0xc5, 0xbf, 0x0d, 0x01, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x77, 0x77, 0x77, 0x03, 0x63, 0x6e, 0x6e, 0x03, 0x63,
	0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01	
	};
	*/
        // Captured by wireshark, same byte order and only extract UDP datagram part

unsigned char DNS_req_packet[29] = {
	0xbf, 0x0d, 0x01, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x77, 0x77, 0x77, 0x03, 0x63, 0x6e, 0x6e, 0x03, 0x63,
	0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01	
	};

        // Mal-formatted DNS request packet will cause segmentation fault
/*
unsigned char DNS_req_packet[29] = {
	0xbf, 0x0d, 0x01, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x77, 0x77, 0x77, 0x03, 0x63, 0x6e, 0x6e, 0x03, 0x63,
	0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01	
	};
*/        
        bool req_ok = true;
	struct DNS_Packet* req_packet = DNS_parse_packet(DNS_req_packet, 29, req_ok);
	if (req_ok)
	    DNS_dump_packet(req_packet);
	else
            printf("\nMalformed packet\n");
	DNS_free_packet(req_packet);
	
	printf("----------------------------------------------------\n\n\n");
    
	// TEST1: DNS Response 1
	
	printf("\nParsing DNS response 1...\n");
	/*
	unsigned char DNS_resp_packet[246] = {
	0xbf, 0x0d, 0x81, 0x80, 0x00, 0x01,
	0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x03, 0x77, 0x77, 0x77, 0x03, 0x63, 0x6e, 0x6e, 0x03, 0x63,
	0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x96, 0x00, 0x04, 0x9d, 0xa6, 0xff, 0x13, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x96, 0x00, 0x04, 0x9d, 0xa6, 0xe0, 0x19, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x96, 0x00, 0x04, 0x9d, 0xa6, 0xe0, 0x1a, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x96, 0x00, 0x04, 0x9d, 0xa6, 0xe2, 0x19, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x96, 0x00, 0x04, 0x9d, 0xa6, 0xe2, 0x1a, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x96, 0x00, 0x04, 0x9d, 0xa6, 0xff, 0x12, 0xc0, 0x0c, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0e,
	0x10, 0x00, 0x11, 0x07, 0x64, 0x6d, 0x74, 0x6e, 0x73, 0x30, 0x31, 0x06, 0x74, 0x75, 0x72, 0x6e,
	0x65, 0x72, 0xc0, 0x14, 0xc0, 0x0c, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x0a,
	0x07, 0x64, 0x6d, 0x74, 0x6e, 0x73, 0x30, 0x32, 0xc0, 0x91, 0xc0, 0x0c, 0x00, 0x02, 0x00, 0x01,
	0x00, 0x00, 0x0e, 0x10, 0x00, 0x0a, 0x07, 0x64, 0x6d, 0x74, 0x6e, 0x73, 0x30, 0x37, 0xc0, 0x91,
	0xc0, 0x89, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x89, 0x00, 0x04, 0x9d, 0xa6, 0xe2, 0xa9,
	0xc0, 0xa6, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x89, 0x00, 0x04, 0x9d, 0xa6, 0xe0, 0xa9,
	0xc0, 0xbc, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x89, 0x00, 0x04, 0x9d, 0xa6, 0xff, 0x0f
	};
	*/
	unsigned char DNS_resp_packet[242] = {
	0x2a, 0xc9, 0x81, 0x80, 0x0, 0x1, 0x0, 0x1, 
	0x0, 0x5, 0x0, 0x5, 0x7, 0x73, 0x6e, 0x31, 0x33, 
	0x32, 0x64, 0x73, 0x4, 0x6d, 0x61, 0x69, 0x6c, 
	0x8, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 
	0x73, 0x4, 0x6c, 0x69, 0x76, 0x65, 0x3, 0x63, 
	0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1, 0xc0, 
	0xc, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 
	0x10, 0x0, 0x4, 0x41, 0x37, 0x48, 0x9a, 0xc0, 
	0x22, 0x0, 0x2, 0x0, 0x1, 0x0, 0x2, 0x18, 
	0x14, 0x0, 0xe, 0x3, 0x6e, 0x73, 0x35, 0x4, 
    0x6d, 0x73, 0x66, 0x74, 0x3, 0x6e, 0x65, 0x74, 
	0x0, 0xc0, 0x22, 0x0, 0x2, 0x0, 0x1, 0x0, 
	0x2, 0x18, 0x14, 0x0, 0x6, 0x3, 0x6e, 0x73, 
	0x33, 0xc0, 0x50, 0xc0, 0x22, 0x0, 0x2, 0x0, 
	0x1, 0x0, 0x2, 0x18, 0x14, 0x0, 0x6, 0x3, 
	0x6e, 0x73, 0x32, 0xc0, 0x50, 0xc0, 0x22, 0x0, 
	0x2, 0x0, 0x1, 0x0, 0x2, 0x18, 0x14, 0x0, 
	0x6, 0x3, 0x6e, 0x73, 0x31, 0xc0, 0x50, 0xc0, 
	0x22, 0x0, 0x2, 0x0, 0x1, 0x0, 0x2, 0x18, 
	0x14, 0x0, 0x6, 0x3, 0x6e, 0x73, 0x34, 0xc0, 
	0x50, 0xc0, 0x8a, 0x0, 0x1, 0x0, 0x1, 0x0, 
	0x0, 0x3, 0xdf, 0x0, 0x4, 0x41, 0x37, 0x25, 
	0x3e, 0xc0, 0x78, 0x0, 0x1, 0x0, 0x1, 0x0, 
	0x0, 0x3, 0xdf, 0x0, 0x4, 0x40, 0x4, 0x3b, 
	0xad, 0xc0, 0x66, 0x0, 0x1, 0x0, 0x1};
        bool resp_ok = true;
	struct DNS_Packet* resp_packet = DNS_parse_packet(DNS_resp_packet, 246, resp_ok);
	if (resp_ok) {
	    DNS_dump_packet(resp_packet);
            std::cout << "Get ID_" << getID(resp_packet) << "_" << std::endl;
            std::cout << "Get Quest_" << getURL(resp_packet) << "_" << std::endl;
        }
	else {
            printf("\nMalformed packet\n");
        }

	DNS_free_packet(resp_packet);
	
	/*
	printf("\nParsing DNS response 2...\n");
	unsigned char DNS_resp_packet[285] = {
	0xc9, 0x2b, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x06, 0x00, 0x03, 0x1a, 0x6e, 0x65, 0x77, 0x73, 0x6c, 0x65, 0x74, 0x74, 0x65, 0x72, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x6c, 0x69, 0x6e, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x05, 0x72, 0x68, 0x73, 0x62, 0x6c, 0x04, 0x61, 0x68, 0x62, 0x6c, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x27, 0x3c, 0x00, 0x04, 0x7f, 0x00, 0x00, 0x02, 0xc0, 0x2b, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x09, 0x03, 0x64, 0x65, 0x31, 0x02, 0x6e, 0x73, 0xc0, 0x31, 0xc0, 0x2b, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x13, 0x04, 0x61, 0x68, 0x62, 0x6c, 0x02, 0x62, 0x6c, 0x06, 0x78, 0x73, 0x34, 0x61, 0x6c, 0x6c, 0x02, 0x6e, 0x6c, 0x00, 0xc0, 0x2b, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x21, 0x07, 0x72, 0x62, 0x6c, 0x64, 0x6e, 0x73, 0x64, 0x01, 0x61, 0x08, 0x72, 0x62, 0x6c, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x02, 0x73, 0x72, 0x05, 0x73, 0x6f, 0x6e, 0x69, 0x63, 0x03, 0x6e, 0x65, 0x74, 0x00, 0xc0, 0x2b, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x0c, 0x07, 0x72, 0x62, 0x6c, 0x64, 0x6e, 0x73, 0x64, 0x01, 0x62, 0xc0, 0x99, 0xc0, 0x2b, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x06, 0x03, 0x6d, 0x69, 0x31, 0xc0, 0x5f, 0xc0, 0x2b, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x07, 0x04, 0x63, 0x61, 0x6c, 0x31, 0xc0, 0x5f, 0xc0, 0x70, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x4d, 0xdd, 0x00, 0x04, 0xc2, 0x6d, 0x09, 0x0a, 0xc0, 0x8f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x4d, 0xdd, 0x00, 0x04, 0xd0, 0xc9, 0xf9, 0xfc, 0xc0, 0xbc, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x4d, 0xdd, 0x00, 0x04, 0xd1, 0xcc, 0x9f, 0x1c
	};
	
        bool resp_ok = true;
	struct DNS_Packet* resp_packet = DNS_parse_packet(DNS_resp_packet, 285, resp_ok);
	if (resp_ok) {
	    DNS_dump_packet(resp_packet);
            std::cout << "Get ID_" << getID(resp_packet) << "_" << std::endl;
            std::cout << "Get Quest_" << getURL(resp_packet) << "_" << std::endl;
        }
	else {
            printf("\nMalformed packet\n");
        }

	DNS_free_packet(resp_packet);
	*/
}

// Command to test: dig @127.0.0.1 www.gmail.com then we can get CNAME in reply
void test_online() {
	
	printf("Test online ...\n");
	
	int sock;
	struct addrinfo local_hints;
    	struct addrinfo* local_result;
    	int err;

    	memset(&local_hints, 0, sizeof(struct addrinfo));
    	local_hints.ai_family = AF_INET;
    	local_hints.ai_socktype = SOCK_DGRAM;
    	local_hints.ai_flags = AI_NUMERICHOST;
    	local_hints.ai_protocol = 0;
	
    	if ((err = getaddrinfo("127.0.0.1", "53", &local_hints, &local_result)) != 0) {
        	fprintf(stderr, "local_getaddrinfo: %s\n", gai_strerror(err));
        	return;
    	}

    	if ((sock = 
	socket(local_result->ai_family, local_result->ai_socktype, local_result->ai_protocol)) == -1) 		{
        	free(local_result);
        	perror("socket");
        	return;
    	}
	
    	if ((err = bind(sock, local_result->ai_addr, local_result->ai_addrlen)) == -1) {
        	free(local_result);
        	perror("bind");
		return;
    	}

    	free(local_result);
	
	// Another forward_sock
	int forward_sock;
	struct addrinfo hints;
    	struct addrinfo* result;
    	int forward_err;

    	memset(&hints, 0, sizeof(struct addrinfo));
    	hints.ai_family = AF_INET;
    	hints.ai_socktype = SOCK_DGRAM;
    	hints.ai_flags = AI_NUMERICHOST;
    	hints.ai_protocol = 0;

    	if ((forward_err = getaddrinfo("8.8.8.8", "53", &hints, &result)) != 0) {
        	fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(forward_err));
        	return;
    	}

    	if ((forward_sock = 
		socket(result->ai_family, result->ai_socktype, result->ai_protocol)) == -1) {
        	free(result);
        	perror("forward_socket");
        	return;
    	}

    	if ((forward_err = connect(forward_sock, result->ai_addr, result->ai_addrlen)) == -1) {
        	free(result);
        	perror("connect");
		return;
    	}

    	free(result);

	if ((err != 0) || (forward_err !=0)) {
	    printf("Bind & Connect Sockets failed, err is %d, foward_err is %d\n", err, forward_err);
	    return;				
	} else {
	    printf("Bind & Connect Sockets OK, err is %d, foward_err is %d. Begin listening\n", err, forward_err);	
            while(1) {
		    int err;
		    size_t len;
		    unsigned char buffer[512];
		    struct sockaddr_storage addr;
		    socklen_t addr_len = sizeof (struct sockaddr_storage);	
		    
		    // Capture DNS req_packet
		    if ((len = 
			recvfrom(sock, buffer, sizeof(buffer), 0, (struct sockaddr*) &addr, &addr_len)) <= 0) 		    {
			printf("Receive packet len %d failed\n", len);
			return;	
		    } else {
			printf("Receive packet len %d OK\n", len);
                        
		        // Parse DNS request
			printf("Dumping DNS request ...\n");
			bool ok = true;
                        struct DNS_Packet* req_p = DNS_parse_packet(buffer, len, ok);
                        if (ok)
			    DNS_dump_packet(req_p);
                        else
                            printf("\nMalformed packet\n");

                        // LAST STEP
                        DNS_free_packet(req_p);
			printf("\nFinish dumping DNS request\n");  
		    }
		
		    printf("Receive packet len %d\n", len);
                    printf("Dump DNS request ...\n"); 
                    for (int i = 0; i< len; i++)
                        printf("%02x ", buffer[i]);
                    printf("\n");
 	            
		    // Create fake DNS request
                    size_t query_len = 0;
                    std::string suffix("dnsbl.sorbs.net");
                    
                    // Size of craft DNS querry can not be know in advance as it depends on suffix and the number of question in buffer, which we haven't parse it yet
		    unsigned char* craft_querry = 
                    (unsigned char*)calloc(512, sizeof(unsigned char));	
		    craft_DNS_query(buffer, len, suffix, craft_querry, query_len);
                    //free(craft_querry);
                    printf("query_len is %d\n", query_len);	

                    // Create fake DNS response
                    std::string TTL("0.0.1.44");
                    std::string IP("202.123.2.6"); // Expect CA 7B 02 06
                    // 16 is size of Answer section, known in advance. Size of craft DNS response will be len + 16
                    unsigned char* data = 
                    (unsigned char*)calloc(len + 16, sizeof(unsigned char));                    
		    
                    craft_DNS_response(buffer, len, TTL, IP, data);
                    
                    printf("Dump Fake DNS response ...\n");
		    for (int i = 0; i< len + 16; i++)
                        printf("%02x ", data[i]);
                    printf("\n");
                    
                    // Parse fake DNS response
                    bool ok = true;
		    struct DNS_Packet* fake_resp_p = DNS_parse_packet(data, len + 16, ok);
                    if (ok) 
		    	DNS_dump_packet(fake_resp_p);
                    else
                        printf("\nMalformed packet\n"); 
		    DNS_free_packet(fake_resp_p);
                    free(data);
		    printf("\nFinish dumping Fake DNS response\n");	

		    // Forward DNS req_packet to DNS server and get response
		    //if ((err = sendto(forward_sock, buffer, len, 0, NULL, 0)) == -1)
		    // Forward fake DNS request packet
            //if ((err = sendto(forward_sock, craft_querry, query_len, 0, NULL, 0)) == -1)
            
			// Forward original DNS request
            if ((err = sendto(forward_sock, buffer, len, 0, NULL, 0)) == -1)
            {
		        printf("Forward packet failed with error %s\n",strerror(errno));
				return;
		    } else {
				// Select
				int ready;
				fd_set fds;
				FD_ZERO(&fds);
				FD_SET(forward_sock, &fds);
				struct timeval tv;
				tv.tv_sec = 2;
				tv.tv_usec = 0;
				if ( (ready = select(forward_sock + 1, &fds, NULL, NULL, &tv)) < 0 )
				{
					printf("Select error. Ready is %d\n", ready);
					return;	
				}
		
				if (FD_ISSET(forward_sock, &fds)) {
					printf("native_sock is SET\n");
					unsigned char buf[512];		
					if ((len = 
						recvfrom(forward_sock, buf, sizeof(buf), 
						0, (struct sockaddr*) &addr, &addr_len)) <= 0)
					{
						printf("Receive DNS response len %d failed\n", len);
						return;	
						} else {
						printf("Receive DNS response len %d OK\n", len);

							// Parse DNS response
						printf("Dumping DNS response ...\n");
											bool ok = true;
						struct DNS_Packet* resp_p = DNS_parse_packet(buf, len, ok);
											if (ok)
							DNS_dump_packet(resp_p);
											else
												printf("\nMalformed packet\n");
											
											// LAST STEP
											DNS_free_packet(resp_p);
						printf("\nFinish dumping DNS response\n");    
						}
				} // end if (FD_ISSET)
		    } // end if sendto
			
            free(craft_querry);
	    } // end while()				
	}
}

void ChangetoDnsNameFormat( char* dns, std::string host) {
  int lock = 0;
  char hostbuf[512];

  strcpy(hostbuf, host.c_str());
  strcat(hostbuf,".");
  
  int inc = 0; 
  for(  int i = 0 ; i < (int)strlen(host.c_str()) + 1  ; i++) {

    if(hostbuf[i]=='.') {
      *(dns + inc)=i-lock;
      inc++;

      for(;lock<i;lock++) {
	*(dns + inc)=hostbuf[lock];
        inc++;
      }
 
      lock++;
    }
  }

  *(dns + inc) = 0x00; 
  inc++; 
}

void warmup() {
	//".multi.surbl.org" = 2e 6d 75 6c 74 69 2e 73 75 72 62 6c 2e 6f 72 67
	std::string RBL(".multi.surbl.org");
        const char* p = RBL.c_str();
        // 2e 6d 75 6c 74 69 2e 73 75 72 62 6c 2e 6f 72 67
        for (int i = 0; i< RBL.length(); i++)
		printf("%02x ", *(p++));
	printf("\n");

        srand(time(NULL));
    	unsigned short id = rand() % 65536;
	printf("%04x ", id);
    	
	unsigned char byteR = id & 0x00ff;
	printf("%02x_", byteR);
      
    	unsigned char byteL = (id & 0xff00) >> 8;
	printf("%02x_", byteL);
	
        std::string host("www.express.pl");
        char *dns = (char *)malloc(256*sizeof(char));
	ChangetoDnsNameFormat(dns, host);
        
        printf("\nBegin testing\n");
	for (int i = 0; i< strlen(dns); i++)
            printf("%02x ", *(dns + i));
        
	printf("\nEnd testing %s\n", dns);
	free(dns);
}

void extra_test() {
}

int main(int argc, char* argv[]){
	
        warmup();
	// Test parser on offline DNS request and response packets
        try {
            test_offline();        
	} catch (...) {
            printf("\nException generated\n");
        };
	
	// Test parser on live DNS request and response packets
	test_online();

        // Extra test
        //extra_test();

	return 0;
}

